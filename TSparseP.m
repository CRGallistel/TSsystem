% TSPARSEP   Flexibly extract information from time & position stamped data.%   This is TSparse modified to deal with 3-col TSData in which the 3rd col%   contains the position of the wheel as of each event. (Of course, many%   of the "events" in the 2nd col are also positions; in those cases 3rd%   col has same value as 2nd col. In addition to the usual special%   variables used in MCODE, this has added POSITION. POSITION(X) gives the%   wheel position.%%   TSPARSE(TSDATA,MCODE,CODELIST) evaluates MCODE based on matching%   CODELIST in TSDATA.  TSDATA represents the TSData.  MCODE denotes the%   Matlab code that will be executed when a match is found.  This code%   should set the variable result to either a row vector of a fixed length%   or it should set result to [].  If the result is [] then nothing will%   be generated for that match.  Otherwise, the current trial number will%   be prepended to result and this row will be added to the previous%   matched rows.  CODELIST denotes a variable number of row vectors%   containing event codes.  These codes will be compared to TSDATA to look%   for a match.  A match results as long as the codes appear in the order%   listed.  There may be other event codes interspersed.  Whichever%   CODELIST matches first will be used to apply the MCODE.  If there is a%   tie, the CODELIST appearing first will be considered the match.  Once a%   match is found, the search will start again following that match and%   including the last code.%%   Within MCODE, a few variables have special meaning.  TIME(X) is the%   time associated with the Xth code to match.  STARTTIME is the starting%   time of the TSDATA.  STOPTIME is the stopping time of the TSDATA.%   Match is the number of the CODELIST that matched.  The first one is 1.%%   When using TSPARSE with both TSTRIALSTAT and TSSESSIONSTAT, a code of %   0 will match the beginning of a session and a code of INF will match %   the end of a session.%%   Total list of special variables for using Eval-style TSparse:%       starttime   - Start timestamp for the entire TSdata passed in%       endtime     - Ending timestamp for the entire TSdata passed in%       match       - Match num of current match%       time        - Times for each of the bindings of current match%       position    - Position of wheel for each of the bindings%       result      - Your code should set this variable, which will be%                     vertically concatenated to the final result. Set to %                     empty if you do not wish to generate a result.%%   Syntax for Feval-style of TSparse%%   function result = MyFunction( match, time, starttime, endtime, varargin )%%   It is possible that more special variables will be added to TSparse in%   the future, so if you want your function to be compatible with future%   versions of TSparse, you need to have a varargin at the end to catch%   new inputs that could potentially show up in the future.%%   See also TSMATCHfunction result1_tsparse = TSparseP(tsdata_tsparse,code_tsparse,varargin)%%   Below you will notice that alot of variables have '_tsparse' appended%   to the end of them. This is to prevent collisions when using "eval" in%   this functions workspace. For example, if someone had a for loop in%   their eval code, and if it was Adam, and he uses "lp" for every loop%   variable, (or if it was me, and I use "x" for every loop variable)%   then there would be a big problem because lp would be overwritten when%   the code is evaluated. Adding _tsparse after the codes prevents this%   collision danger because no one in their right mind would use%   lp_tsparse as a variable name.%TSdeclareeventcodes; % Declare event codes so that they can be used in evalcode.result1_tsparse=[];starttime=tsdata_tsparse(1,1);    % Start timeendtime=tsdata_tsparse(end,1);    % End timestartposition=tsdata_tsparse(1,3); % Start positionstopposition=tsdata_tsparse(end,3); % End positionif nargin < 3    error ('Match codes not supplied to TSparse, check the documentation.');    return;endif numel(varargin) == 1 && iscell(varargin{1})    % This is for the case that a single vector is passed in                                                  % as a cell array (a                                                  % varargin). Buty... Why                                                  % are we allowing for                                                  % varargins?    varargin = varargin{1};end[matches_tsparse,bindings_tsparse]=TSmatch(tsdata_tsparse,varargin);  if ischar(code_tsparse)    for lp_tsparse=1:length(matches_tsparse);    % For each successful match        match=matches_tsparse(lp_tsparse);        time = tsdata_tsparse(bindings_tsparse{lp_tsparse}, 1);        position = tsdata_tsparse(bindings_tsparse{lp_tsparse}, 3);        result=[];        eval(code_tsparse);        result1_tsparse = [result1_tsparse; result];  % Changed 7/8/09    end;    elseif isa(code_tsparse, 'function_handle')        for lp=1:length(matches_tsparse);    % For each successful match        match=matches_tsparse(lp);        time = tsdata_tsparse(bindings_tsparse{lp}, 1);        position = tsdata_tsparse(bindings_tsparse{lp}, 3);        result = code_tsparse(match, time, starttime, endtime, position);        if (~isempty(result)) % If code returns a nonempty value, appends            % result of code in resultl_tsparse            result1_tsparse=[result1_tsparse; result];        end    end;end